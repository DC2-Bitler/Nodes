#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string>
#include <sys/types.h>
#include <math.h>
#include <string.h>
#include <string>
#include <cstdlib>
#include <time.h>
#include "gpioclass.h"


using namespace std;

void gpioOpen(void);
void gpioClose(void);

int main(int argc, char *argv[])
{
    int listenfd = 0, connfd = 0;
    int n = 0;
    struct sockaddr_in serv_addr;
    int challange = 0;
    int answer = 0;
    int listen_answer = 0;
    int command_state = -1;
    char open_code[9] =  "0000OPEN";
    char close_code[9] =  "0000CLOS";

    char sendBuff[9];
    char recvBuff[9];
    char answer_string[5];
    srand(time(NULL));

    listenfd = socket(AF_INET, SOCK_STREAM, 0);
    memset(&serv_addr, '0', sizeof(serv_addr));
    memset(sendBuff, '0', sizeof(sendBuff));
    memset(recvBuff, '0', sizeof(recvBuff));

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_addr.sin_port = htons(5347);

    bind(listenfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

    listen(listenfd, 10);

    while(1)
    {
        command_state = -1;
        connfd = accept(listenfd, (struct sockaddr*)NULL, NULL);
        printf("\nClient connected from port %d\n", connfd);

        n = recv(connfd, recvBuff, sizeof(recvBuff)-1, 0);
        recvBuff[n] = 0;
        printf("Client sent: %s\n", recvBuff);
        if(strcmp(recvBuff, open_code) == 0)
        {
            command_state = 1;
        }else if(strcmp(recvBuff, close_code) == 0)
        {
            command_state = 2;
        }else{
            printf("Invalid Command.\n");
            goto END;
        }

        challange = rand()%9999;
        answer = ((challange * 7)/4) % 9999;
        if(answer < 10) answer += 10;
        if(answer < 100) answer += 100;
        if(answer < 1000) answer += 1000;

        printf("Challange number: %d\n", challange);
        printf("Answer number: %d\n", answer);

        sprintf(sendBuff, "%dCHAL", challange);
        memset(recvBuff, '0', sizeof(recvBuff));

        send(connfd, sendBuff, strlen(sendBuff), 0);

        n = recv(connfd, recvBuff, sizeof(recvBuff)-1, 0);
        recvBuff[n] = 0;
        printf("Client sent: %s\n", recvBuff);

        if(n < 0){
            printf("Read error \n");
        }else{
            for(int i = 0; i < 4; i++){
                answer_string[i] = recvBuff[i];
            }
            answer_string[4] = '\0';
            listen_answer = atoi(answer_string);
        }

        if((listen_answer == answer))
        {
	  if(command_state == 1){
	    gpioOpen();
	  }else{
	    gpioClose();
	  }
            printf("Operation Succeeded.\n");  
        }else{
            printf("Operation Failed.\n");
        }

END:
        close(connfd);
        sleep(1);
    }
}

void gpioOpen(void)
{
    GPIOClass* openLock = new GPIOClass("25");
    GPIOClass* closeLock = new GPIOClass("24");

    openLock->export_gpio();
    closeLock->export_gpio();

    openLock->setdir_gpio("out");
    closeLock->setdir_gpio("out");

    closeLock->setval_gpio("0");
    openLock->setval_gpio("1");
    usleep(20000);
    openLock->setval_gpio("0");

    delete openLock;
    openLock = 0;

    delete closeLock;
    closeLock = 0;
}

void gpioClose(void)
{
    GPIOClass* openLock = new GPIOClass("25");
    GPIOClass* closeLock = new GPIOClass("24");

    openLock->export_gpio();
    closeLock->export_gpio();

    openLock->setdir_gpio("out");
    closeLock->setdir_gpio("out");

    openLock->setval_gpio("0");
    closeLock->setval_gpio("1");
    usleep(20000);
    closeLock->setval_gpio("0");

    delete openLock;
    openLock = 0;

    delete closeLock;
    closeLock = 0;

}
